<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>sklearn.cluster.DBSCAN</title>
           <style type="text/css">
        body {
            font-family: verdana, arial, sans-serif;
        }
        b {
            font-size: 125%;
            color: blue;
        }
        i {
            font-size: 110%;
            color: green;
        }
    </style>
</head>
<body>

<div><p>
    На этом занятии мы с вами применим алгоритм DNSCAN для кластеризации географических
    данных, и в вместе с этим изучим способ определения значений параметров эпсилон и mpts.
    У меня есть небольшой датасет на 14 тысяч точек, для каждой из которых известна ее
    координата в широте и долготе. Для того чтобы визуализировать эти точки, я использую
    некоторое дополнение к библиотеке Matpotlib, которое скорей всего у вас не установлено,
    и вам нужно будет это сделать самостоятельно. Называется basemap. Ну и помимо этого
    есть функция, которая уже рисует точки на карте, она уже реализована, вам нужно ее
    просто запустить. Пока карта рисуется, я объясню, в чем заключается способ оценки
    параметров для DBSCAN. Заключается он в следующем. Вначале нам нужно понять, какой
    размер кластера мы будем считать подходящим, чтобы он был выделен, то есть нам нужно
    заранее указать значения minpts. Ну например, по каким-то соображениям мы считаем, что
    минимум точек в кластере должно быть равно 20, то есть minpts должно быть равно 20.
    Теперь исходя из этого я хочу понять, какое же значение эпсилон адекватно мне выставить.
    Сделать это нужно следующим образом: нужно посчитать расстояние для каждой точки от ее
    mpts-нутого ближайшего соседа. Далее эти расстояния сортируются по возрастанию и
    визуализируются. И по полученному графику мы можем примерно прикинуть, какой эпсилон
    нам стоит использовать. Для начала я переведу свои данные из широты и долготы в радианы.
    Сделать это можно с помощью метода radians на np или вы можете сами, если помните, как
    это делается. Таким образом, в матрице x у нас содержатся координаты в радианах. Теперь
    для того, чтобы посчитать расстояние до mpts-нутого ближайшего соседа, я воспользуюсь
    классом NearestNeighbors из библиотеки sklearn. В качестве аргумента я передам
    количество ближайших соседей, в данном случае мы договорились, что оно будет равно 20.
    В аргумент algorithm я передам значение ball_tree. Это специальная структура для того,
    чтобы быстро рассчитывать расстояние в пространственных данных. И в качестве метрики я
    буду использовать не евклидово расстояние, а специальное расстояние для географических
    точек havesine distance. Ну отлично. Теперь я фичу NearestNeighbor на наши данные, и
    теперь я хочу посчитать расстояние до mpts-нутого ближайшего соседа. Снова обращаюсь к
    модели ближайшего соседа, и к конкретно к методу kneighbors. Я передаю данные, количество
    ближайших соседей, которые я хочу достать, и флаг того, что я хочу возвращать не просто
    индексы этих ближайших соседей, а их расстояние. Собственно только они мне и нужны.
    Сами индексы я хранить нигде не буду. Пока производятся вычисления, я напишу код для
    того чтобы понять, какого размера у нас получился массив dist. Но он получился на самом
    деле размера количество точек на 20, потому что у нас 20 ближайших соседей.
    Соответственно мне нужен только 20-й столбец этого массива, что я и выделю. Теперь этот
    массив я отсортирую по возрастанию и визуализирую. На этом графике по оси x у нас идет
    просто число от 0 до 13467, а по оси y отложено расстояние до mpts-нутого ближайшего
    соседа. Так вот способ оценивания эпсилон по этому графику заключается в том, что мы
    должны выбрать эпсилон, на котором этот график начинает резко возрастать. Аргументация
    этого метода заключается в том, что если мы например выберем эпсилон равный 0,005, то
    есть где-то здесь мы пересечем наш график, то это значит, что все те точки, которые
    находятся по правую сторону от этой точки, будут либо граничными, либо выбросами. Ну и
    далее, в зависимости от того, сколько мы хотим чтобы было выбросов, мы как-то пытаемся
    прикинуть значение эпсилон. Я установлю эпсилон = 0,002. Теперь я буду кластеризовывать
    объекты с помощью DBSCANа. Для этого из sklearn я импортирую соответствующий класс,
    создам экземпляр этой модели. В качестве эпсилон я указываю эпсилон, который я только
    что оценил. min_samples=20, metric='haversine', и алгоритм тоже ball_tree. И фичу на
    данных. Пока выполняются вычисления, я заранее напишу код, для того чтобы сохранить
    метки полученных кластеров. Для этого я обращусь к атрибуту labels с нижним
    подчеркиванием. Посмотрим, сколько же кластеров у нас получилось и каковы их размеры.
    Для удобства я запихну метки в pd.Series и применю к ним метод value.counts. Вот у нас
    получилось довольно много кластеров, и те объекты, которые помечены как выбросы, имеют
    метку −1. Ну а теперь давайте визуализируем ту же самую карту, с тем исключением, что
    мы выкинем оттуда объекты, которые являются выбросами. Для этого я создам специальную
    маску, в которой будет содержаться true для всех объектов-невыбросов, и немножко
    подкорректирую входные аргументы в функцию для рисования. Для широты, для долготы и
    наконец там есть аргумент labels, в который я передам лейблы за исключением выбросов,
    чтобы точки имели разный цвет. Подождем, пока выполнится визуализация. Вот, визуализация
    получена. Мы видим, что карта получилась более чистой, чем она была. Мы удалили довольно
    много выбросов. Ну а дальше остается анализировать эти кластеры и переподбирать значения
    параметров эпсилон по этому графику.
</p></div>

</body>
</html>