<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Практика. Метод K-средних</title>
    <style type="text/css">
        body {
            font-family: verdana, arial, sans-serif;
        }
        b {
            font-size: 125%;
            color: blue;
        }
        i {
            font-size: 110%;
            color: green;
        }
    </style>
</head>
<>
<div><p>
      На этом занятии мы применим алгоритм k-средних на игрушечных данных и используем метод 
    локтя, для того чтобы определить оптимальное k для соответствующего датасета. Я 
    импортировал уже все необходимые мне стандартные библиотеки типа <b>Pandas</b>, 
    <b>Numpy</b> и <b>Matplotlib</b>. Дополнительно я воспользуюсь библиотекой 
    <b>sklearn.datasets</b>, для того чтобы генерировать игрушечные данные. Таким образом, 
    я сгенерирую 150 объектов, имеющие два признака и разделенные на четыре кластера. 
    Можно это все дело визуализировать, чтобы понять, как выглядят наши данные. Я 
    воспользуюсь функцией scatter, чтобы видеть эти облака из четырех кластеров. Теперь 
    воспользуемся <i>sklearn</i>, для того чтобы обучить на этих данных алгоритм k-средних. 
    Импортируем его из sklearn. import KMeans. Теперь создадим экземпляр класса KMeans. 
    Посмотрим, какие у него есть атрибуты. Во-первых, это количество кластеров n_clusters, 
    далее init — способ инициализации центроидов, мы с вами разобрали, что такое KMeans++, 
    и здесь же мы его будем использовать так же. Дальше, n_init=10, это значит, что KMeans 
    будет инициализироваться случайным образом десять раз, и в конечном счете будет выбрано 
    то разбиение, которое имеет наилучшее значение критерия KMeans. <i>max_iter</i> — окей, 
    <i>tol</i> — окей, и последнее, что нам понадобится, <i>random_state</i>. random_state 
    нужен для того, чтобы у вас и у меня получались одинаковые результаты после применения 
    KMeans.</p>
    <p>Давайте поставим n_clusters от какой-нибудь балды, например, <i>2, init='k-means++'</i>. 
    А n_init тоже 10, и random_state пусть будет 1. Обучим алгоритм, для этого воспользуемся 
    методом <i>fit</i>. Все, KMeans обучен, теперь мы можем получить метки кластеров. 
    Сделать это довольно просто, для этого нужно обратиться к атрибуту <i>kmeans.labels_</i>. 
    И у нас уже появился массив с метками кластеров соответствующих объектов. Мы можем также 
    это дело визуализировать. Воспользуемся все той же функцией scatter, но теперь в 
    атрибут c добавим массив с метками кластеров. Вот у нас получились два наших кластера. 
    Теперь давайте поймем, какое k оказывается наилучшим для данного датасета, и для этого 
    мы используем метод локтя. Что нам нужно? Нам нужно итеративно для разных k применять 
    метод k-средних и смотреть на значения критерия k-средних. Это значит, что, во-первых, 
    нам нужен будет список, в котором мы будем хранить значения критерия k-средних. Далее в 
    цикле от k, например, от 2 до 8 мы будем обучать, создавать новый экземпляр класса 
    KMeans с разным количеством кластеров. И также выставим атрибут random_state, равным 1, 
    так чтобы у нас с вами получались одинаковые результаты. Дальше нужно сделать fit на 
    данных и в последнюю очередь нужно будет сохранять значение критерия KMeans. Сделать это 
    можно, обратившись к атрибуту inertia_. Таким образом, в нашем списке будут храниться 
    значения критерия качества KMeans. А теперь давайте это дело визуализируем. 
    Воспользуемся функцией <b>lt.plot</b>, по оси x у нас будет k, которое мы перебирали, 
    от 2 до 8, а по оси y — значения критерия. Вот, видим до боли знакомую картину. И в 
    данном случае оптимальным количеством кластеров для данного датасета по критерию локтя 
    оказывается количество, равное четырем. И это тоже можно визуализировать, то есть мы 
    применим метод KMeans для четырех кластеров при k=4 и посмотрим на визуализацию 
    полученных кластеров. Да, получилась довольно неплохая кластеризация, довольно похожая 
    на то, что было заложено в генерации данных. Таким образом, мы с вами научились 
    пользоваться методом KMeans с помощью библиотеки sklearn и также методом локтя, для 
    того чтобы оценить оптимальное k для каждого датасета.
  
</p></div>

</body>
</html>